// Copyright 2018 The CCGO Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Command ccgo is a C compiler targeting Go.
package main

/*

jnml@4670:~/src/github.com/ossrs/librtmp> make clean && make CC=ccgo
rm -f *.o rtmpdump rtmpgw rtmpsrv rtmpsuck
/home/jnml/src/github.com/ossrs/librtmp/librtmp
make[1]: Entering directory '/home/jnml/src/github.com/ossrs/librtmp/librtmp'
rm -f *.o *.a *.so *.so.1 librtmp.pc
make[1]: Leaving directory '/home/jnml/src/github.com/ossrs/librtmp/librtmp'
/home/jnml/src/github.com/ossrs/librtmp/librtmp
make[1]: Entering directory '/home/jnml/src/github.com/ossrs/librtmp/librtmp'
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\" -DUSE_OPENSSL  -O2 -fPIC   -c -o rtmp.o rtmp.c
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\" -DUSE_OPENSSL  -O2 -fPIC   -c -o log.o log.c
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\" -DUSE_OPENSSL  -O2 -fPIC   -c -o amf.o amf.c
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\" -DUSE_OPENSSL  -O2 -fPIC   -c -o hashswf.o hashswf.c
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\" -DUSE_OPENSSL  -O2 -fPIC   -c -o parseurl.o parseurl.c
ar rs librtmp.a rtmp.o log.o amf.o hashswf.o parseurl.o
ar: creating librtmp.a
ccgo -shared -Wl,-soname,librtmp.so.1  -o librtmp.so.1 rtmp.o log.o amf.o hashswf.o parseurl.o  -lssl -lcrypto -lz
ln -sf librtmp.so.1 librtmp.so
make[1]: Leaving directory '/home/jnml/src/github.com/ossrs/librtmp/librtmp'
ccgo -Wall   -DRTMPDUMP_VERSION=\"v2.4\"   -O2   -c -o rtmpdump.o rtmpdump.c
ccgo -Wall  -o rtmpdump rtmpdump.o -Llibrtmp -lrtmp -lssl -lcrypto -lz
ccgo: error: unrecognized command line option "-Llibrtmp"
Makefile:79: recipe for target 'rtmpdump' failed
make: *** [rtmpdump] Error 2
jnml@4670:~/src/github.com/ossrs/librtmp>

*/

//TODO must be able to handle libssl, libcrypto and libz (zlib?)

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/cznic/cc/v2"
	"github.com/cznic/ccgo/v2"
	"github.com/cznic/ccgo/v2/internal/object"
)

const (
	crt   = "crt."
	crt0c = "crt0.c"

	pkgHeader = `// Code generated by '%s', DO NOT EDIT.

package %s

import (
	"math"
	"os"
	"unsafe"

	"github.com/cznic/crt"
)

const (
	null = uintptr(0)
)

var (
	_ = math.Pi
	_ = unsafe.Pointer(null)

	nz32 float32
	nz64 float64
)

func init() { nz32 = -nz32 }
func init() { nz64 = -nz64 }

func alloca(p *[]uintptr, n int) uintptr   { r := %[3]sMustMalloc(n); *p = append(*p, r); return r }
func preinc(p *uintptr, n uintptr) uintptr { *p += n; return *p }

`

	mainHeader = `func main() {
	psz := unsafe.Sizeof(uintptr(0))
	argv := crt.MustCalloc((len(os.Args) + 1) * int(psz))
	p := argv
	for _, v := range os.Args {
		*(*uintptr)(unsafe.Pointer(p)) = %[3]sCString(v)
		p += psz
	}
	a := os.Environ()
	env := crt.MustCalloc((len(a) + 1) * int(psz))
	p = env
	for _, v := range a {
		*(*uintptr)(unsafe.Pointer(p)) = %[3]sCString(v)
		p += psz
	}
	*(*uintptr)(unsafe.Pointer(Xenviron)) = env
	X_start(%[3]sNewTLS(), int32(len(os.Args)), argv)
}

`
)

var (
	log     = func(string, ...interface{}) {}
	logging bool
)

func main() {
	r, err := main1(os.Args)
	if err != nil {
		fmt.Fprintln(os.Stderr, strings.TrimSpace(expandError(err).Error()))
	}
	os.Exit(r)
}

type config struct {
	D  []string // -D
	I  []string // -I
	L  []string // -L
	Wl []string // -Wl,
	l  []string // -l
	o  string   // -o

	arg0      string
	args      []string
	goarch    string
	goos      string
	incPaths  []string
	linkOrder []string
	objMap    map[string]string
	objects   []string
	osArgs    []string
	remove    []string
	sysPaths  []string

	E      bool // -E
	c      bool // -c
	dM     bool // -dM
	m64    bool // -m64
	shared bool // -shared
}

func newConfig(args []string) (*config, error) {
	if len(args) == 0 {
		return nil, fmt.Errorf("no arguments to parse")
	}

	c := &config{
		arg0:     args[0],
		goarch:   env("GOARCH", runtime.GOARCH),
		goos:     env("GOOS", runtime.GOOS),
		incPaths: []string{"@"},
		objMap:   map[string]string{},
		osArgs:   args,
	}
	args = args[1:]
	for len(args) != 0 {
		switch arg := args[0]; {
		case strings.HasPrefix(arg, "-D"):
			a := strings.SplitN(arg, "=", 2)
			if len(a) == 1 {
				a = append(a, "1")
			}
			c.D = append(c.D, fmt.Sprintf("%s %s", a[0][2:], a[1]))
		case arg == "-c":
			c.c = true
		case arg == "-o":
			if len(args) < 2 {
				return nil, fmt.Errorf("-o option requires an argument")
			}

			c.o = args[1]
			args = args[1:]
		case arg == "-dM":
			c.dM = true
		case arg == "-m64":
			c.E = true
		case arg == "-E":
			c.E = true
		case arg == "-I":
			if len(args) < 2 {
				return nil, fmt.Errorf("-I option requires an argument")
			}

			c.I = append(c.I, args[1])
			args = args[1:]
		case strings.HasPrefix(arg, "-I"):
			c.I = append(c.I, arg[2:])
		case arg == "-L":
			if len(args) < 2 {
				return nil, fmt.Errorf("-L option requires an argument")
			}

			c.L = append(c.L, args[1])
			args = args[1:]
		case strings.HasPrefix(arg, "-L"):
			c.L = append(c.L, arg[2:])
		case arg == "-shared":
			c.shared = true
		case strings.HasPrefix(arg, "-l"):
			s := arg[2:]
			c.l = append(c.l, s)
			c.linkOrder = append(c.linkOrder, arg)
		case strings.HasPrefix(arg, "-Wl,"):
			c.Wl = strings.Split(arg[4:], ",")
		case !strings.HasPrefix(arg, "-"):
			c.args = append(c.args, arg)
			c.linkOrder = append(c.linkOrder, arg)
		case
			arg == "-g",
			arg == "-pthread",
			strings.HasPrefix(arg, "-O"),
			strings.HasPrefix(arg, "-W"),
			strings.HasPrefix(arg, "-f"):

			// ignored
		default:
			return nil, fmt.Errorf("%s: error: unrecognized command line option %q %v", c.arg0, arg, args)
		}
		args = args[1:]
	}
	if c.m64 {
		switch c.goarch {
		default:
			return nil, fmt.Errorf("-m64 invalid architecture %s", c.goarch)
		}
	}
	c.incPaths = append(c.incPaths, c.I...)
	c.sysPaths = append(c.sysPaths, c.I...)
	return c, nil
}

func main1(args []string) (r int, err error) {
	if fn := os.Getenv("CCGOLOG"); fn != "" {
		logging = true
		var f *os.File
		if f, err = os.OpenFile(fn, os.O_APPEND|os.O_CREATE|os.O_WRONLY|os.O_SYNC, 0644); err != nil {
			return 1, err
		}

		pid := fmt.Sprintf("[pid %v] ", os.Getpid())

		log = func(s string, args ...interface{}) {
			s = fmt.Sprintf(pid+s, args...)
			switch {
			case len(s) != 0 && s[len(s)-1] == '\n':
				fmt.Fprint(f, s)
			default:
				fmt.Fprintln(f, s)
			}
		}

		defer func() {
			log("---- exit status %v, err %v", r, err)
			f.Close()
		}()

		log("==== %v", args)
	}

	returned := false

	defer func() {
		e := recover()
		if !returned && e != nil {
			err = errs(err, fmt.Errorf("PANIC: %v #%s", e, debugStack2()))
		}
	}()

	c, err := newConfig(args)
	if err != nil {
		return 2, err
	}

	if len(c.args) == 0 {
		return 2, fmt.Errorf(`
%s: fatal error: no input files
compilation terminated`, c.arg0)
	}

	localSysPaths, err := cc.Paths(true)
	if err != nil {
		return 1, err
	}

	sysPaths, err := cc.Paths(false)
	if err != nil {
		return 1, err
	}

	c.sysPaths = append(c.sysPaths, localSysPaths...)
	c.sysPaths = append(c.sysPaths, sysPaths...)
	for _, in := range c.args {
		switch ext := filepath.Ext(in); ext {
		case ".c":
			if err = c.compile(in); err != nil {
				return 1, err
			}
		case ".a", ".o":
			c.objects = append(c.objects, in)
			c.objMap[in] = in
		default:
			return 1, fmt.Errorf("%s: file not recognized", in)
		}
	}
	if c.c || c.E {
		returned = true
		return 0, nil
	}

	if c.shared {
		if err = c.linkShared(); err != nil {
			returned = true
			return 1, err
		}

		returned = true
		return 0, nil
	}

	defer func() {
		for _, v := range c.remove {
			os.Remove(v)
		}
	}()

	if err := c.link(); err != nil {
		return 1, err
	}

	returned = true
	return 0, nil
}

type linkerConfig struct {
	rpath   []string // -rpath
	soname  string
	sonames []string // -soname

	exportDynamic bool
}

func newLinkerConfig(args []string) (*linkerConfig, error) {
	c := &linkerConfig{}
	for ; len(args) != 0; args = args[1:] {
		switch arg := args[0]; {
		case arg == "--export-dynamic":
			c.exportDynamic = true
		case arg == "-rpath":
			if len(args) < 2 {
				return nil, fmt.Errorf("missing -rpath argument")
			}

			c.rpath = append(c.rpath, args[1])
			args = args[1:]
		default:
			return nil, fmt.Errorf("unknown/unsupported linker option: %q", arg)
		}
	}
	if len(c.sonames) > 1 {
		return nil, fmt.Errorf("multiple -sonam options: %s", strings.Join(c.sonames, ""))
	}
	return c, nil
}

func (c *config) linkShared() (err error) {
	lc, err := newLinkerConfig(c.Wl)
	if err != nil {
		return err
	}

	var fn string
	if c.o != "" {
		fn = c.o
	}
	if fn == "" && lc.soname != "" {
		fn = lc.soname
	}
	if fn == "" {
		fn = "a.so"
	}

	f, err := os.Create(fn)
	if err != nil {
		return err
	}

	defer func() { err = errs(err, f.Close()) }()

	b := bufio.NewWriter(f)

	defer func() { err = errs(err, b.Flush()) }()

	r, w := io.Pipe()
	var e2 error

	go func() {
		defer func() {
			if err := recover(); err != nil && e2 == nil {
				e2 = fmt.Errorf("%v", err)
			}
			if err := w.Close(); err != nil && e2 == nil {
				e2 = err
			}
		}()

		if lc.soname != "" {
			if _, e2 = fmt.Fprintf(w, "const Lsoname = %q\n\n", lc.soname); e2 != nil {
				return
			}
		}

		for _, v := range c.linkOrder {
			switch {
			case strings.HasPrefix(v, "-l"):
				//TODO
			default:
				fn := c.objMap[v]
				if fn == "" {
					e2 = fmt.Errorf("internal error: missing object for %q", v)
					return
				}

				if _, e2 = fmt.Fprintf(w, "\n\nconst Lsofile = %q\n\n", fn); e2 != nil {
					return
				}

				f, err := os.Open(fn)
				if err != nil {
					e2 = err
					return
				}

				if e2 = object.Decode(w, c.goos, c.goarch, object.ObjVersion, object.ObjMagic, bufio.NewReader(f)); e2 != nil {
					return
				}
			}
		}
	}()

	err = ccgo.NewSharedObject(b, c.goos, c.goarch, r)
	if err == nil {
		err = e2
	}
	return err
}

func (c *config) link() (err error) {
	fn := "a.out"
	if c.goos == "windows" {
		fn = "a.exe"
	}
	if c.o != "" {
		fn = c.o
	}

	if filepath.Ext(fn) == ".go" {
		return c.linkGo(fn)
	}

	dir, err := ioutil.TempDir("", "ccgo-linker-")
	if err != nil {
		return err
	}

	defer func() { err = errs(err, os.RemoveAll(dir)) }()

	src := filepath.Join(dir, "main.go")
	if err := c.linkGo(src); err != nil {
		return err
	}

	cmd := exec.Command("go", "build", "-o", fn, src)
	for _, v := range os.Environ() {
		if v != "CC=ccgo" {
			cmd.Env = append(cmd.Env, v)
		}
	}
	if co, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s\n%v", co, err)
	}

	return nil
}

func (c *config) linkGo(fn string) (err error) {
	pkgName := toExt(filepath.Base(fn), "")

	f, err := os.Create(fn)
	if err != nil {
		return err
	}

	out := bufio.NewWriter(f)
	defer func() { err = errs(err, out.Flush()) }()

	l, err := ccgo.NewLinker(out, c.goos, c.goarch)
	if err != nil {
		return err
	}

	header := fmt.Sprintf(pkgHeader, strings.Join(c.osArgs, " "), pkgName, crt)

	defer func() { err = errs(err, l.Close(header)) }()

	for _, fn := range c.objects { //TODO use linkOrder
		if err = c.linkFile(l, fn); err != nil {
			return err
		}
	}
	if l.Main {
		header = fmt.Sprintf(pkgHeader+mainHeader, strings.Join(c.osArgs, " "), "main", crt)
		crt0o := toExt(crt0c, ".o")
		if err = c.compileSource(crt0o, crt0c, cc.NewStringSource(crt0c, cc.CRT0Source)); err != nil {
			return err
		}

		if err = c.linkFile(l, crt0o); err != nil {
			return err
		}
	}
	return nil
}

func (c *config) linkFile(l *ccgo.Linker, fn string) (err error) {
	var f *os.File
	if f, err = os.Open(fn); err != nil {
		return err
	}

	defer func() { err = errs(err, f.Close()) }()

	switch ext := filepath.Ext(fn); ext {
	case ".a":
		r, err := newArReader(f)
		if err != nil {
			return err
		}

		for r.Next() {
			if err := l.Link(fn, r); err != nil {
				return fmt.Errorf("%s: %v", fn, err)
			}
		}
		return r.err
	case ".o":
		if err := l.Link(fn, bufio.NewReader(f)); err != nil {
			return fmt.Errorf("%s: %v", fn, err)
		}
	default:
		return fmt.Errorf("unknown linker object type: %s", ext)
	}

	return nil
}

func (c *config) compile(in string) (err error) {
	out := filepath.Base(toExt(in, ".o"))
	if c.c && c.o != "" {
		if len(c.args) > 1 {
			return fmt.Errorf("-o cannot be used with -c and multiple input files")
		}

		out = c.o
	}
	if log != nil {
		b, err := ioutil.ReadFile(in)
		if err != nil {
			return err
		}

		log("file %s\n%s\n----", in, b)
	}
	src, err := cc.NewFileSource2(in, true)
	if err != nil {
		return err
	}

	return c.compileSource(out, in, src)
}

func (c *config) compileSource(out, in string, src cc.Source) (err error) {
	c.objects = append(c.objects, out)
	c.objMap[in] = out
	if !c.c {
		c.remove = append(c.remove, out)
	}
	defs := []string{`
#define _DEFAULT_SOURCE 1
#define _POSIX_C_SOURCE 200809
#define _POSIX_SOURCE 1
#define __FUNCTION__ __func__ // gcc compatibility
#define __ccgo__ 1
`}
	for _, v := range c.D {
		defs = append(defs, fmt.Sprintf("#define %s", v))
	}

	tweaks := &cc.Tweaks{
		// TrackExpand:   func(s string) { fmt.Print(s) },
		// TrackIncludes: func(s string) { fmt.Printf("[#include %s]\n", s) },
		EnableAnonymousStructFields: true,
		EnableEmptyStructs:          true,
		EnableImplicitBuiltins:      true,
		EnableOmitFuncDeclSpec:      true,
		EnableReturnExprInVoidFunc:  true,
		EnableUnionCasts:            true,
		InjectFinalNL:               true,
	}

	sources := []cc.Source{cc.NewStringSource("<defines>", strings.Join(defs, "\n"))}
	builtin, err := cc.Builtin()
	if err != nil {
		return err
	}

	sources = append(sources, builtin)

	if c.E {
		tweaks.PreprocessOnly = true
		switch {
		case c.dM:
			prev := "\n"
			last := "\n"
			tweaks.DefinesOnly = true
			tweaks.TrackExpand = func(s string) {
				ts := strings.TrimSpace(s)
				if !strings.HasPrefix(ts, "#") {
					return
				}

				ts = strings.TrimSpace(ts[1:])
				if !strings.HasPrefix(ts, "define") {
					return
				}
				s += "\n"
				if s == "\n" && last == "\n" && prev == "\n" {
					return
				}

				fmt.Print(s)
				prev = last
				last = s
			}
		default:
			prev := "\n"
			last := "\n"
			tweaks.TrackExpand = func(s string) {
				ts := strings.TrimSpace(s)
				if strings.HasPrefix(ts, "#") {
					return
				}

				if s == "\n" && last == "\n" && prev == "\n" {
					return
				}

				fmt.Print(s)
				prev = last
				last = s

			}
		}
	}
	sources = append(sources, src)
	tu, err := cc.Translate(tweaks, c.incPaths, c.sysPaths, sources...)
	if err != nil {
		return err
	}

	if c.E {
		return nil
	}

	f, err := os.Create(out)
	if err != nil {
		return err
	}

	defer func() { err = errs(err, f.Close()) }()

	b := bufio.NewWriter(f)

	defer func() { err = errs(err, b.Flush()) }()

	return ccgo.NewObject(b, c.goos, c.goarch, src.Name(), tu)
}
